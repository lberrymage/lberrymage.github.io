<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ina, Part 1: Smaller, faster, and safer software updates for Accrescent | Logan's Blog</title>
<meta name=keywords content><meta name=description content="Introduction Well! It&rsquo;s been a long time since I&rsquo;ve shared an Accrescent update here (most development discussion takes place in our Matrix rooms), but today I have a big one: we&rsquo;ve made significant progress in developing delta updates!
&ldquo;That sounds great and fancy!&rdquo; I hear you say, &ldquo;but what in the world are delta updates, and why would I care?&rdquo;
Well, to give a quick summary, delta updates bring your software update sizes from looking like this:"><meta name=author content="Logan Magee"><link rel=canonical href=https://lberrymage.dev/posts/ina-part-1/><link crossorigin=anonymous href=/assets/css/stylesheet.5d45b8bd1a3cf526e72959d51f1bdc688d8e97fa0df2a697a93df6bdc746feb4.css integrity="sha256-XUW4vRo89SbnKVnVHxvcaI2Ol/oN8qaXqT32vcdG/rQ=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://lberrymage.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lberrymage.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lberrymage.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://lberrymage.dev/apple-touch-icon.png><link rel=mask-icon href=https://lberrymage.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lberrymage.dev/posts/ina-part-1/><meta property="og:title" content="Ina, Part 1: Smaller, faster, and safer software updates for Accrescent"><meta property="og:description" content="Introduction Well! It&rsquo;s been a long time since I&rsquo;ve shared an Accrescent update here (most development discussion takes place in our Matrix rooms), but today I have a big one: we&rsquo;ve made significant progress in developing delta updates!
&ldquo;That sounds great and fancy!&rdquo; I hear you say, &ldquo;but what in the world are delta updates, and why would I care?&rdquo;
Well, to give a quick summary, delta updates bring your software update sizes from looking like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://lberrymage.dev/posts/ina-part-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-17T13:35:34-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ina, Part 1: Smaller, faster, and safer software updates for Accrescent"><meta name=twitter:description content="Introduction Well! It&rsquo;s been a long time since I&rsquo;ve shared an Accrescent update here (most development discussion takes place in our Matrix rooms), but today I have a big one: we&rsquo;ve made significant progress in developing delta updates!
&ldquo;That sounds great and fancy!&rdquo; I hear you say, &ldquo;but what in the world are delta updates, and why would I care?&rdquo;
Well, to give a quick summary, delta updates bring your software update sizes from looking like this:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://lberrymage.dev/posts/"},{"@type":"ListItem","position":2,"name":"Ina, Part 1: Smaller, faster, and safer software updates for Accrescent","item":"https://lberrymage.dev/posts/ina-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ina, Part 1: Smaller, faster, and safer software updates for Accrescent","name":"Ina, Part 1: Smaller, faster, and safer software updates for Accrescent","description":"Introduction Well! It\u0026rsquo;s been a long time since I\u0026rsquo;ve shared an Accrescent update here (most development discussion takes place in our Matrix rooms), but today I have a big one: we\u0026rsquo;ve made significant progress in developing delta updates!\n\u0026ldquo;That sounds great and fancy!\u0026rdquo; I hear you say, \u0026ldquo;but what in the world are delta updates, and why would I care?\u0026rdquo;\nWell, to give a quick summary, delta updates bring your software update sizes from looking like this:","keywords":[],"articleBody":"Introduction Well! It’s been a long time since I’ve shared an Accrescent update here (most development discussion takes place in our Matrix rooms), but today I have a big one: we’ve made significant progress in developing delta updates!\n“That sounds great and fancy!” I hear you say, “but what in the world are delta updates, and why would I care?”\nWell, to give a quick summary, delta updates bring your software update sizes from looking like this:\nto this:\nIf you’re curious as to how, keep reading. 1\nBackground In a basic software update system, the update process looks something like this:\nDownload the newest version of the software to disk. Replace the old software files with the new ones. For the sake of convenience, we’ll refer to this process as the “naive approach.”\nThere isn’t anything wrong with the naive approach per se; it’s simple, it works, and it’s relatively easy to implement. Many software update systems still work this way. However, when working with wide-scale deployments, the naive approach suffers from a considerable issue: a full copy of the latest software must be distributed to each client. 2\nThis is turn causes higher bandwidth costs for both clients and the server operator, less frequent updates (which may contain security fixes!), slower rollout, and more update interruptions which may require starting the update over from the beginning. The client-facing issues are especially troublesome in countries where Wi-Fi isn’t commonplace and cellular data is slow and expensive. Clearly, a solution to reduce these update sizes would be beneficial for both clients and the update server operator. But how can we do this?\nAttempt 1: Data compression Perhaps the most obvious first step to reduce update size is to apply generic data compression. Using zstd at level 19, we get the following results:\nNot bad! But these results are still far from the delta update sizes shown in the introduction. So how can we possibly reduce them further?\nData compression in theory While deep data compression theory is outside the scope of this article, a brief description of how data compression works will help understand the approach to solving this problem. In general, data compression algorithms exploit patterns in data to represent said data in fewer bytes. For example, say we want to compress the sequence “AAAA”. We easily see that we’re only using one character, A, and that it repeats four times. We could design a compression scheme which exploits this pattern by encoding it as a character followed by how many repeats of that character exist. 3 In this example, we could compress our input sequence to “A4,” a 50% size reduction.\nAnother important concept to understand is that the more you know about the type and format of the data you’re compressing, the more specific patterns you can detect and potentially exploit to reduce compressed file size. Expanding the above example, let’s say we know that our data contains only the characters “A” and “B.” Thus, we can represent each character as 1 bit (0 representing A, and 1 representing B). If our length value is encoded as 8 bits, we can then represent “A4” in 9 bits (as opposed to the 16 we would use if encoding “A” an as ASCII value).\nWith that out of the way, let’s move on to delta updates!\nAttempt 2: Delta updates We’ve discussed how data compression exploits patterns to represent data in fewer bytes. So what patterns exist in software updates that we can exploit to reduce the size of our software updates? As it turns out, there are two very important ones:\nThe new software is usually very similar to the old software with some sparse changes. The files being updated are usually executable software. We’ll leave the second point up for discussion in part 2 of this series where we’ll explain the algorithm that Accrescent’s delta update system uses in more detail. The first point is more fundamental to delta update algorithms in general, and it prompts the question: if the new software is mostly the same as the old software, what if we encoded only the differences between the two and just copied data from the old software when it hasn’t changed? That is, instead of viewing a software update like this:\nwhat if we viewed it like this:\nand only sent the changes to the client? 4\nHere we have arrived at the concept of delta updates.\nOur solution Delta updates themselves are not a novel idea. Windows, Google Play, Chrome, Android, and more use some form of delta updates to reduce software update sizes. Some of these are partially or completely open-source, making it theoretically possible to adapt one of them for Accrescent’s usage. However, existing implementations suffer from some or all of the following issues, some of them directly counter to Accrescent’s goals:\nThey are written in memory-unsafe languages like C and C++, making them prone to security vulnerabilities and thus undesirable to use in a security-sensitive context. They use an excess of main memory when diffing (creating a delta update) and/or patching (applying a delta update), making them unsuitable for devices with low memory such as mobile phones and some VPSs. They have little to no testing, raising questions about their correctness and robustness against bug classes outside of memory corruption (which can also be a security concern). They have no Android library wrapper. Because of this, we decided to create a custom solution to the delta update problem with the following goals:\nMemory-safe implementation language Low memory requirements Batteries-included Android library Sandboxed Android patching Thorough testing Comparable diff and patch performance to existing implementations We’re happy to say that this effort has been successful with all of the above goals met. 5 We call the resulting library “Ina.”\nPerformance results Of course, numbers speak louder than words, so we’ve included some results on how Ina stacks up against the competition, specifically against one of the most common open-source implementations of delta updates: bsdiff. Below are the results.\nAll numbers were taken as an average of 3 runs on an Arch Linux system with an Intel Core Ultra 7 155H processor and LPDDR5 memory running at 6400 Mhz. The original version of bsdiff 4.3 was compiled with the default Arch package manager compiler flags plus -O3. Ina was compiled in release mode without any additional compiler flags. Measurements were taken using GNU time. 1\nAnalysis Across the board, Ina consistently uses significantly less memory than bsdiff when both diffing and patching. Diffing time is comparable, with bsdiff taking a slight lead for dockerd, but Ina taking a drastic lead for node. We don’t know the exact cause of this, but may investigate in a later part of this series. Delta size was comparable between the two programs with Ina taking a slight lead. Ina took a drastic lead in patching time. However, it should be noted that patching time may not matter much in practice depending on the hardware because it’s so low to begin with.\nConclusion We’ve successfully developed a performant, safe, and robust solution for delta updates to incorporate into Accrescent. While there are still ways to improve diffing performance and strengthen the library sandbox, 5 we’ve already made significant security and performance improvements over existing delta update solutions and are confident we can implement the additional improvements we have planned.\nIn part 2 of this series, we’ll explore exactly how Ina achieves its performance characteristics and perhaps investigate alternative algorithms and performance tricks Ina could take advantage of to further improve its performance.\nThat’s all for this one! If you want to keep up on more Accrescent developments, join our Matrix rooms, follow the Accrescent socials, or keep an eye on this blog where I’ll be posting the next part of this series on Ina and delta updates.\nAll numbers in this post are based on the following Arch Linux x86_64 binaries: dockerd 24.0.7 and 25.0.2, node 20.11.0 and 20.11.1, and godot 4.1.2 and 4.1.3. ↩︎ ↩︎\nAll active clients with a network connection, of course. Not every client will receive every update, especially if the software in question updates frequently, as a newer update may be released before a client attempts to update to the previous release. ↩︎\nThis is called run-length encoding (RLE). While not often used on its own, RLE is used in practice as a part of many popular compression schemes. ↩︎\nThis is an oversimplification. Instructions specifying where to place the changes in the new binary and which bytes to copy verbatim from the old binary are also necessary, but I decided to omit this from the diagram as the details of the algorithm will be explained in part 2. ↩︎\nThe original version of this article stated we didn’t have Android sandboxing implemented. Sandboxing was implemented only a few days later, so we updated the text to reflect this. ↩︎ ↩︎\n","wordCount":"1480","inLanguage":"en","datePublished":"2024-03-20T00:00:00Z","dateModified":"2024-04-17T13:35:34-07:00","author":{"@type":"Person","name":"Logan Magee"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lberrymage.dev/posts/ina-part-1/"},"publisher":{"@type":"Organization","name":"Logan's Blog","logo":{"@type":"ImageObject","url":"https://lberrymage.dev/favicon.ico"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://lberrymage.dev/ accesskey=h title="Logan's Blog (Alt + H)">Logan's Blog</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Ina, Part 1: Smaller, faster, and safer software updates for Accrescent</h1><div class=post-meta><span title='2024-03-20 00:00:00 +0000 UTC'>March 20, 2024</span>&nbsp;·&nbsp;Logan Magee</div><div class=post-meta><span title="2024-04-17 13:35:34 -0700 -0700"><i>Last updated on April 17, 2024</i></span></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#background aria-label=Background>Background</a></li><li><a href=#attempt-1-data-compression aria-label="Attempt 1: Data compression">Attempt 1: Data compression</a><ul><li><a href=#data-compression-in-theory aria-label="Data compression in theory">Data compression in theory</a></li></ul></li><li><a href=#attempt-2-delta-updates aria-label="Attempt 2: Delta updates">Attempt 2: Delta updates</a></li><li><a href=#our-solution aria-label="Our solution">Our solution</a></li><li><a href=#performance-results aria-label="Performance results">Performance results</a></li><li><a href=#analysis aria-label=Analysis>Analysis</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>Well! It&rsquo;s been a long time since I&rsquo;ve shared an <a href=https://accrescent.app>Accrescent</a> update here (most development
discussion takes place in our <a href=https://matrix.to/#/#accrescent-space:matrix.org>Matrix rooms</a>), but today I have a big one: we&rsquo;ve made significant
progress in developing delta updates!</p><p>&ldquo;That sounds great and fancy!&rdquo; I hear you say, &ldquo;but what in the world are delta updates, and why
would I care?&rdquo;</p><p>Well, to give a quick summary, delta updates bring your software update sizes from looking like
this:</p><p><img loading=lazy src=/delta-updates-naive.png alt="Naive delta update sizes for various programs"></p><p>to this:</p><p><img loading=lazy src=/delta-updates-delta.png alt="Delta update sizes for various programs"></p><p>If you&rsquo;re curious as to how, keep reading. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h1 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h1><p>In a basic software update system, the update process looks something like this:</p><p><img loading=lazy src=/delta-updates-naive-visual.png alt="Visualization of the naive approach"></p><ol><li>Download the newest version of the software to disk.</li><li>Replace the old software files with the new ones.</li></ol><p>For the sake of convenience, we&rsquo;ll refer to this process as the &ldquo;naive approach.&rdquo;</p><p>There isn&rsquo;t anything <em>wrong</em> with the naive approach per se; it&rsquo;s simple, it works, and it&rsquo;s
relatively easy to implement. Many software update systems still work this way. However, when
working with wide-scale deployments, the naive approach suffers from a considerable issue: a full
copy of the latest software must be distributed to each client. <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>This is turn causes higher bandwidth costs for both clients and the server operator, less frequent
updates (which may contain security fixes!), slower rollout, and more update interruptions which may
require starting the update over from the beginning. The client-facing issues are especially
troublesome in countries where Wi-Fi isn&rsquo;t commonplace and cellular data is slow and expensive.
Clearly, a solution to reduce these update sizes would be beneficial for both clients and the update
server operator. But how can we do this?</p><h1 id=attempt-1-data-compression>Attempt 1: Data compression<a hidden class=anchor aria-hidden=true href=#attempt-1-data-compression>#</a></h1><p>Perhaps the most obvious first step to reduce update size is to apply generic data compression.
Using zstd at level 19, we get the following results:</p><p><img loading=lazy src=/delta-updates-naive-compressed.png alt="Compressed update sizes compared against the naive approach"></p><p>Not bad! But these results are still far from the delta update sizes shown in the introduction. So
how can we possibly reduce them further?</p><h2 id=data-compression-in-theory>Data compression in theory<a hidden class=anchor aria-hidden=true href=#data-compression-in-theory>#</a></h2><p>While deep data compression theory is outside the scope of this article, a brief description of how
data compression works will help understand the approach to solving this problem. In general, data
compression algorithms exploit patterns in data to represent said data in fewer bytes. For example,
say we want to compress the sequence &ldquo;AAAA&rdquo;. We easily see that we&rsquo;re only using one character, A,
and that it repeats four times. We could design a compression scheme which exploits this pattern by
encoding it as a character followed by how many repeats of that character exist. <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> In this
example, we could compress our input sequence to &ldquo;A4,&rdquo; a 50% size reduction.</p><p>Another important concept to understand is that the more you know about the type and format of the
data you&rsquo;re compressing, the more specific patterns you can detect and potentially exploit to reduce
compressed file size. Expanding the above example, let&rsquo;s say we know that our data contains only the
characters &ldquo;A&rdquo; and &ldquo;B.&rdquo; Thus, we can represent each character as 1 bit (0 representing A, and 1
representing B). If our length value is encoded as 8 bits, we can then represent &ldquo;A4&rdquo; in 9 bits (as
opposed to the 16 we would use if encoding &ldquo;A&rdquo; an as ASCII value).</p><p>With that out of the way, let&rsquo;s move on to delta updates!</p><h1 id=attempt-2-delta-updates>Attempt 2: Delta updates<a hidden class=anchor aria-hidden=true href=#attempt-2-delta-updates>#</a></h1><p>We&rsquo;ve discussed how data compression exploits patterns to represent data in fewer bytes. So what
patterns exist in software updates that we can exploit to reduce the size of our software updates?
As it turns out, there are two very important ones:</p><ul><li>The new software is usually very similar to the old software with some sparse changes.</li><li>The files being updated are usually executable software.</li></ul><p>We&rsquo;ll leave the second point up for discussion in part 2 of this series where we&rsquo;ll explain the
algorithm that Accrescent&rsquo;s delta update system uses in more detail. The first point is more
fundamental to delta update algorithms in general, and it prompts the question: if the new software
is mostly the same as the old software, what if we encoded <em>only the differences</em> between the two
and just copied data from the old software when it hasn&rsquo;t changed? That is, instead of viewing a
software update like this:</p><p><img loading=lazy src=/delta-updates-naive-visual.png alt="Visualization of the naive approach"></p><p>what if we viewed it like this:</p><p><img loading=lazy src=/delta-updates-delta-visual.png alt="Visualization of the delta update approach"></p><p>and only sent the changes to the client? <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><p>Here we have arrived at the concept of delta updates.</p><h1 id=our-solution>Our solution<a hidden class=anchor aria-hidden=true href=#our-solution>#</a></h1><p>Delta updates themselves are not a novel idea. <a href="https://devblogs.microsoft.com/oldnewthing/20200212-00/?p=103434">Windows</a>, <a href=https://android-developers.googleblog.com/2016/07/improvements-for-smaller-app-downloads.html>Google Play</a>, <a href=https://www.chromium.org/developers/design-documents/software-updates-courgette/>Chrome</a>, <a href=https://source.android.com/docs/core/ota/tools#incremental-updates>Android</a>, and
more use some form of delta updates to reduce software update sizes. Some of these are partially or
<a href=https://chromium.googlesource.com/chromium/src/courgette/>completely</a> open-source, making it theoretically possible to adapt one of them for Accrescent&rsquo;s
usage. However, existing implementations suffer from some or all of the following issues, some of
them directly counter to Accrescent&rsquo;s goals:</p><ul><li>They are written in memory-unsafe languages like C and C++, making them <a href=https://nvd.nist.gov/vuln/detail/CVE-2014-9862>prone to security
vulnerabilities</a> and thus undesirable to use in a security-sensitive context.</li><li>They use an excess of main memory when diffing (creating a delta update) and/or patching (applying
a delta update), making them unsuitable for devices with low memory such as mobile phones and some
VPSs.</li><li>They have little to no testing, raising questions about their correctness and robustness against
bug classes outside of memory corruption (which can also be a security concern).</li><li>They have no Android library wrapper.</li></ul><p>Because of this, we decided to create a custom solution to the delta update problem with the
following goals:</p><ul><li>Memory-safe implementation language</li><li>Low memory requirements</li><li>Batteries-included Android library</li><li>Sandboxed Android patching</li><li>Thorough testing</li><li>Comparable diff and patch performance to existing implementations</li></ul><p>We&rsquo;re happy to say that this effort has been successful with all of the above goals met. <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> We
call the resulting library &ldquo;Ina.&rdquo;</p><h1 id=performance-results>Performance results<a hidden class=anchor aria-hidden=true href=#performance-results>#</a></h1><p>Of course, numbers speak louder than words, so we&rsquo;ve included some results on how Ina stacks up
against the competition, specifically against one of the most common open-source implementations of
delta updates: <a href=https://www.daemonology.net/bsdiff/>bsdiff</a>. Below are the results.</p><p>All numbers were taken as an average of 3 runs on an Arch Linux system with an Intel Core Ultra 7
155H processor and LPDDR5 memory running at 6400 Mhz. The original version of bsdiff 4.3 was
compiled with the default Arch package manager compiler flags plus <code>-O3</code>. Ina was compiled in
release mode without any additional compiler flags. Measurements were taken using GNU <code>time</code>. <sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p><img loading=lazy src=/delta-updates-perf-diff-time.png alt="Diffing speed performance chart"></p><p><img loading=lazy src=/delta-updates-perf-diff-mem.png alt="Diffing maximum memory usage performance chart"></p><p><img loading=lazy src=/delta-updates-perf-delta-size.png alt="Delta size performance chart"></p><p><img loading=lazy src=/delta-updates-perf-patch-time.png alt="Patching speed performance chart"></p><p><img loading=lazy src=/delta-updates-perf-patch-mem.png alt="Patching maximum memory usage performance chart"></p><h1 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h1><p>Across the board, Ina consistently uses significantly less memory than bsdiff when both diffing and
patching. Diffing time is comparable, with bsdiff taking a slight lead for dockerd, but Ina taking a
drastic lead for node. We don&rsquo;t know the exact cause of this, but may investigate in a later part of
this series. Delta size was comparable between the two programs with Ina taking a slight lead. Ina
took a drastic lead in patching time. However, it should be noted that patching time may not matter
much in practice depending on the hardware because it&rsquo;s so low to begin with.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>We&rsquo;ve successfully developed a performant, safe, and robust solution for delta updates to
incorporate into Accrescent. While there are still ways to improve diffing performance and
strengthen the library sandbox, <sup id=fnref1:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> we&rsquo;ve already made significant security and performance
improvements over existing delta update solutions and are confident we can implement the additional
improvements we have planned.</p><p>In part 2 of this series, we&rsquo;ll explore exactly how Ina achieves its performance characteristics and
perhaps investigate alternative algorithms and performance tricks Ina could take advantage of to
further improve its performance.</p><p>That&rsquo;s all for this one! If you want to keep up on more Accrescent developments, join our <a href=https://matrix.to/#/#accrescent-space:matrix.org>Matrix
rooms</a>, follow the <a href=https://accrescent.app/#social>Accrescent socials</a>, or keep an eye on this blog where I&rsquo;ll be posting the next
part of this series on Ina and delta updates.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>All numbers in this post are based on the following Arch Linux x86_64 binaries: dockerd 24.0.7
and 25.0.2, node 20.11.0 and 20.11.1, and godot 4.1.2 and 4.1.3.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>All active clients with a network connection, of course. Not every client will receive every
update, especially if the software in question updates frequently, as a newer update may be
released before a client attempts to update to the previous release.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>This is called <a href=https://en.wikipedia.org/wiki/Run-length_encoding>run-length encoding</a> (RLE). While not often used on its own, RLE is used in
practice as a part of many popular compression schemes.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>This is an oversimplification. Instructions specifying where to place the changes in the new
binary and which bytes to copy verbatim from the old binary are also necessary, but I decided to
omit this from the diagram as the details of the algorithm will be explained in part 2.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The original version of this article stated we didn&rsquo;t have Android sandboxing implemented.
Sandboxing was implemented only a few days later, so we updated the text to reflect this.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>Copyright 2022-2024 Logan Magee</span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.727d74878dd0d630d592de1483de40c9393b9d59c42ec34eeac2b18635dd8959.js integrity="sha256-cn10h43Q1jDVkt4Ug95AyTk7nVnELsNO6sKxhjXdiVk="></script></body></html>